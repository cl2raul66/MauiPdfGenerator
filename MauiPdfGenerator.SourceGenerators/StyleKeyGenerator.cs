using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Collections.Immutable;
using System.Globalization;
using System.Text;

namespace MauiPdfGenerator.SourceGenerators
{
    [Generator]
    public class StyleKeyGenerator : IIncrementalGenerator
    {
        private const string GeneratedClassNamespace = "MauiPdfGenerator.Styles";
        private const string GeneratedClassName = "PdfStyles";
        private const string GeneratedFileName = "PdfStyles.g.cs";
        private const string PdfStyleIdentifierFullName = "global::MauiPdfGenerator.Fluent.Models.PdfStyleIdentifier";

        private const string TargetInterface = "MauiPdfGenerator.Fluent.Interfaces.Builders.IPdfResourceBuilder";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var styleCalls = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (node, _) => IsPotentialStyleCall(node),
                    transform: static (ctx, ct) => GetStyleKeyIfValid(ctx, ct))
                .Where(static key => key is not null)!;

            var collectedKeys = styleCalls.Collect();

            context.RegisterSourceOutput(collectedKeys,
                static (spc, keys) => GenerateSource(spc, keys));
        }

        static bool IsPotentialStyleCall(SyntaxNode node)
        {
            return node is InvocationExpressionSyntax inv &&
                   inv.Expression is MemberAccessExpressionSyntax memberAccess &&
                   memberAccess.Name.Identifier.Text == "Style";
        }

        static string? GetStyleKeyIfValid(GeneratorSyntaxContext context, CancellationToken ct)
        {
            var invocation = (InvocationExpressionSyntax)context.Node;

            if (invocation.ArgumentList.Arguments.Count < 2)
                return null;

            var firstArg = invocation.ArgumentList.Arguments[0];
            if (firstArg.Expression is not LiteralExpressionSyntax literal ||
                !literal.IsKind(SyntaxKind.StringLiteralExpression))
            {
                return null;
            }

            string styleKey = literal.Token.ValueText;
            if (string.IsNullOrWhiteSpace(styleKey)) return null;

            var symbolInfo = context.SemanticModel.GetSymbolInfo(invocation, ct);

            if (symbolInfo.Symbol is IMethodSymbol methodSymbol)
            {
                if (IsTargetInterface(methodSymbol.ContainingType)) return styleKey;
            }
            else if (!symbolInfo.CandidateSymbols.IsEmpty)
            {
                foreach (var candidate in symbolInfo.CandidateSymbols)
                {
                    if (candidate is IMethodSymbol candidateMethod &&
                        IsTargetInterface(candidateMethod.ContainingType))
                    {
                        return styleKey;
                    }
                }
            }

            return null;
        }

        static bool IsTargetInterface(INamedTypeSymbol typeSymbol)
        {
            if (typeSymbol.ToDisplayString() == TargetInterface)
                return true;

            foreach (var iface in typeSymbol.AllInterfaces)
            {
                if (iface.ToDisplayString() == TargetInterface)
                    return true;
            }
            return false;
        }

        static void GenerateSource(SourceProductionContext context, ImmutableArray<string?> keys)
        {
            if (keys.IsDefaultOrEmpty) return;

            var uniqueKeys = new HashSet<string>(StringComparer.Ordinal);
            foreach (var key in keys)
            {
                if (key is not null) uniqueKeys.Add(key);
            }

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine($"namespace {GeneratedClassNamespace}");
            sb.AppendLine("{");
            sb.AppendLine($"    public static partial class {GeneratedClassName}");
            sb.AppendLine("    {");

            var usedIdentifiers = new HashSet<string>(StringComparer.Ordinal);
            var keysList = uniqueKeys.ToList();

            for (int i = 0; i < keysList.Count; i++)
            {
                var key = keysList[i];
                string identifier = CreateValidCSharpIdentifier(key);

                if (usedIdentifiers.Contains(identifier)) continue;
                usedIdentifiers.Add(identifier);

                sb.AppendLine($"        /// <summary>Style key for '{EscapeString(key)}'.</summary>");
                sb.AppendLine($"        public static {PdfStyleIdentifierFullName} {identifier} {{ get; }} = new {PdfStyleIdentifierFullName}(\"{EscapeString(key)}\");");

                if (i < keysList.Count - 1)
                {
                    sb.AppendLine();
                }
            }

            sb.AppendLine("    }");
            sb.Append("}");

            context.AddSource(GeneratedFileName, SourceText.From(sb.ToString(), Encoding.UTF8));
        }

        private static string EscapeString(string text) => text.Replace("\"", "\\\"");

        private static string CreateValidCSharpIdentifier(string input)
        {
            if (string.IsNullOrWhiteSpace(input)) return "_Style";

            string normalized = RemoveDiacritics(input);

            var sb = new StringBuilder();
            bool lastWasUnderscore = false;

            foreach (char c in normalized)
            {
                if (char.IsLetterOrDigit(c) || c == '_')
                {
                    sb.Append(c);
                    lastWasUnderscore = (c == '_');
                }
                else if (!lastWasUnderscore)
                {
                    sb.Append('_');
                    lastWasUnderscore = true;
                }
            }

            string result = sb.ToString().Trim('_');

            if (string.IsNullOrEmpty(result)) return "_Style";

            if (char.IsDigit(result[0]))
                result = "_" + result;

            if (SyntaxFacts.GetKeywordKind(result) != SyntaxKind.None)
                return "@" + result;

            return result;
        }

        private static string RemoveDiacritics(string text)
        {
            var normalizedString = text.Normalize(NormalizationForm.FormD);
            var stringBuilder = new StringBuilder(capacity: normalizedString.Length);

            for (int i = 0; i < normalizedString.Length; i++)
            {
                char c = normalizedString[i];
                var unicodeCategory = CharUnicodeInfo.GetUnicodeCategory(c);
                if (unicodeCategory != UnicodeCategory.NonSpacingMark)
                {
                    stringBuilder.Append(c);
                }
            }

            return stringBuilder
                .ToString()
                .Normalize(NormalizationForm.FormC);
        }
    }
}